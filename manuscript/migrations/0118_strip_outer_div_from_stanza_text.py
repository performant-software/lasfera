# Generated by Django 5.1.15 on 2026-01-15 17:33

from django.db import migrations


def strip_outer_divs(apps, schema_editor):
    """Data migration to strip any <div></div> automatically
    added by the rich text editor on stanza_text for Stanza
    and StanzaTranslated instances."""

    Stanza = apps.get_model("manuscript", "Stanza")
    StanzaTranslated = apps.get_model("manuscript", "StanzaTranslated")

    for model in (Stanza, StanzaTranslated):
        for stanza in model.objects.all().iterator():
            if not stanza.stanza_text:
                continue

            text = stanza.stanza_text.strip()

            if text.startswith("<div>") and text.endswith("</div>"):
                cleaned = text[len("<div>") : -len("</div>")].strip()
                stanza.stanza_text = cleaned
                stanza.save(update_fields=["stanza_text"])


def find_all_positions(text, search_string):
    """Find all occurrences of search_string in text and return their positions
    (from mgmt command reconnect_annotations.py)"""
    positions = []
    start = 0
    while True:
        start = text.find(search_string, start)
        if start == -1:  # No more occurrences
            break
        positions.append((start, start + len(search_string)))
        start += 1  # Move past the current occurrence
    return positions


def remap_annotations(apps, schema_editor):
    """Remap annotations to stanzas and translated stanzas based on text
    content and position.
    (mostly from mgmt command reconnect_annotations.py, repeated here to avoid
    relying on command code in migrations)"""

    TextualVariant = apps.get_model("textannotation", "TextualVariant")
    EditorialNote = apps.get_model("textannotation", "EditorialNote")
    CrossReference = apps.get_model("textannotation", "CrossReference")
    Stanza = apps.get_model("manuscript", "Stanza")
    StanzaTranslated = apps.get_model("manuscript", "StanzaTranslated")
    ContentType = apps.get_model("contenttypes", "ContentType")

    # Get content types for both models
    stanza_type = ContentType.objects.get_for_model(Stanza)
    translated_type = ContentType.objects.get_for_model(StanzaTranslated)
    ct_map = {
        stanza_type.id: Stanza,
        translated_type.id: StanzaTranslated
    }

    annotation_models = [EditorialNote, CrossReference, TextualVariant]
    for AnnotationModel in annotation_models:
        annotations = AnnotationModel.objects.all()

        # check all annotation types
        annotation_models = [EditorialNote, CrossReference, TextualVariant]

        for AnnotationModel in annotation_models:
            annotations = AnnotationModel.objects.all()

            for annotation in annotations:
                selected_text = annotation.selected_text
                if not selected_text:
                    continue
                try:
                    # Try to convert position to integer, handle various formats
                    if isinstance(annotation.from_pos, dict):
                        original_position = None
                    else:
                        original_position = int(str(annotation.from_pos))
                except (ValueError, TypeError):
                    original_position = None

                # try to find a match in the original object id, content type
                found_in_original = False
                if annotation.content_type_id in ct_map and annotation.object_id:
                    StanzaModel = ct_map[annotation.content_type_id]
                    try:
                        # fetch the specific object this annotation points to
                        target_obj = StanzaModel.objects.get(id=annotation.object_id)
                        
                        # check if the text is still there
                        if target_obj.stanza_text and selected_text in target_obj.stanza_text:
                            positions = find_all_positions(target_obj.stanza_text, selected_text)
                            best_match_pos = None
                            
                            if len(positions) == 1:
                                best_match_pos = positions[0]
                            elif len(positions) > 1 and original_position is not None:
                                # disambiguate inside the same object
                                closest_distance = float("inf")
                                for start, end in positions:
                                    distance = abs(start - original_position)
                                    if distance < closest_distance:
                                        closest_distance = distance
                                        best_match_pos = (start, end)
                            if best_match_pos:
                                annotation.from_pos = best_match_pos[0]
                                annotation.to_pos = best_match_pos[1]
                                annotation.save()
                                found_in_original = True
                    except StanzaModel.DoesNotExist:
                        # original object is gone, proceed to fallback
                        pass

                if found_in_original:
                    # skip searching other model/instances if already found
                    continue

                matches_found = []

                # Search in both models
                for model, content_type in [
                    (Stanza, stanza_type),
                    (StanzaTranslated, translated_type),
                ]:
                    for obj in model.objects.filter(
                        stanza_text__contains=selected_text
                    ):
                        # Find all occurrences in this object
                        positions = find_all_positions(obj.stanza_text, selected_text)

                        for start, end in positions:
                            matches_found.append(
                                {
                                    "model": model.__name__,
                                    "object": obj,
                                    "start": start,
                                    "end": end,
                                    "content_type": content_type,
                                }
                            )

                if len(matches_found) == 1:
                    # Single match - straightforward case
                    match = matches_found[0]
                    annotation.content_type = match["content_type"]
                    annotation.object_id = match["object"].id
                    annotation.from_pos = match["start"]
                    annotation.to_pos = match["end"]
                    annotation.save()

                elif len(matches_found) > 1:
                    # Multiple matches - try to use position data to disambiguate
                    best_match = None
                    if original_position is not None:
                        # Find the match closest to the original position
                        closest_distance = float("inf")
                        for match in matches_found:
                            distance = abs(match["start"] - original_position)
                            if distance < closest_distance:
                                closest_distance = distance
                                best_match = match

                    if (
                        best_match and closest_distance < 50
                    ):  # Threshold for position matching
                        annotation.content_type = best_match["content_type"]
                        annotation.object_id = best_match["object"].id
                        annotation.from_pos = best_match["start"]
                        annotation.to_pos = best_match["end"]
                        annotation.save()


class Migration(migrations.Migration):

    dependencies = [
        ("manuscript", "0117_delete_stanzavariant"),
        ("textannotation", "0005_alter_textualvariant_notes"),
    ]

    operations = [
        migrations.RunPython(strip_outer_divs, migrations.RunPython.noop),
        migrations.RunPython(remap_annotations, migrations.RunPython.noop),
    ]
